import argparse
import ast
import math
from collections import Counter

def taxa_mappings():
  taxaID2Lineage = {}
  for i in open(args.f):
      tmp = i.strip().upper().split('|')
      taxaID = tmp[0].strip()
      taxaName = tmp[1].lower().strip()
      lineage = tmp[2].lower().strip()+';'+taxaName
      taxaID2Lineage[taxaID] = lineage
  return taxaID2Lineage

def LCA(lineages):
    lineages = [x.split(';') for x in lineages]
    new_lineage = [i[0].strip() for i in zip(*lineages) if len(set(i)) == 1 if '' not in i]
    return new_lineage

parser = argparse.ArgumentParser()
parser.add_argument("-d", help="diamond output file")
parser.add_argument("-m", help="marker gene mapping file")
parser.add_argument("-c", help="marker gene thresholds file")
parser.add_argument("-t", help="proportion of range(smax - nmax) to not use for classification",default=0.1,type=float)
parser.add_argument("-f", help="NCBI fullnamelineage.dmp file")
args = parser.parse_args()

taxaID2Lineage = taxa_mappings()

print('collected taxonomy dictionary')

classifiers = {}

for i in open(args.d):
	tmp = i.strip().split('\t')
	MG,start,end = tmp[1],int(tmp[8]),int(tmp[9])
	region = str(int(20 * math.floor(min(start,end)/20)))
	MG_region = MG+'_'+region
	classifiers[MG_region] = {}

print('diamond file first pass')

for i in open(args.c):
	tmp = i.strip().split('\t')
	region = tmp[0]
	if region in classifiers:
		thresholds = ast.literal_eval(tmp[1])
		classifiers[region] = thresholds

print('collected relevant classifiers')

metadata = {}

for i in open(args.m):
        tmp = i.strip().split('\t')
        prot,MG,species,genus,family = tmp[0],tmp[1],tmp[3],tmp[4],tmp[5]
        metadata[prot] = [MG,species,genus,family]

print('collected relevant metadata for marker genes')

read_classifications = {}

with open('classified_reads.txt','w') as out:
	for i in open(args.d):
		tmp = i.strip().split('\t')
		read,MG,aln_len,start,end,bitscore = tmp[0],tmp[1],float(tmp[3]),int(tmp[8]),int(tmp[9]),float(tmp[11])
		if aln_len >= 30:
			region = str(int(20 * math.floor(min(start,end)/20)))
			MG_region = MG+'_'+region
			if classifiers[MG_region] != {}: # classifier for region must exist in classifiers
				nmax,smin,smax,gmin,gmax,fmin,fmax = classifiers[MG_region]
				threshold = ((smax - nmax)*args.t) + nmax
				negative_range = nmax/smax
				if negative_range >= 0.95: continue
				busco,species,genus,family = metadata[MG]
				mean_bitscore = bitscore/aln_len
				if mean_bitscore < threshold: continue
				lineage = ''
				if mean_bitscore >= smin:
					lineage = taxaID2Lineage[species]
					out.write(read+'\t'+'species'+'\t'+busco+'\t'+MG_region+'\t'+str(mean_bitscore)+'\t'+lineage+'\n')
				elif gmin != 'na':
					if mean_bitscore >= gmin:
						lineage = taxaID2Lineage[genus]
						out.write(read+'\t'+'genus'+'\t'+busco+'\t'+MG_region+'\t'+str(mean_bitscore)+'\t'+lineage+'\n')
				elif fmin != 'na':
					if mean_bitscore >= fmin:
						lineage = taxaID2Lineage[family]
						out.write(read+'\t'+'family'+'\t'+busco+'\t'+MG_region+'\t'+str(mean_bitscore)+'\t'+lineage+'\n')
				if lineage != '':
					if read not in read_classifications:
						read_classifications[read] = [[lineage],set([busco])]
					else:
						read_classifications[read][0].append(lineage)
						read_classifications[read][1].update([busco])

sample_taxa = {}

with open('final_read_classifications.txt','w') as out:
        for read,v in read_classifications.items():
                lineages,buscos = v[0],v[1]
                lca = LCA(lineages)
                line = ';'.join(lca)
                out.write(read+'\t'+line+'\t'+','.join(list(buscos))+'\n')
                if line not in sample_taxa:
                    sample_taxa[line] = [set([read]),buscos]
                else:
                    sample_taxa[line][0].update([read])
                    sample_taxa[line][1].update(buscos)

print('final read classifications produced')

aggregate_taxa = {}

with open('validation.txt','w') as out:
  for k,v in sample_taxa.items():
    counts,buscos,len_counts = v[0],v[1],len(v[0])
    if len_counts < 2: continue
    if len(buscos) < 2: continue
    if len(buscos) < 6:
        if len_counts > 1.7**len(buscos): continue
    for i in counts:
        out.write(i+'\t'+k+'\n')
    line = ''
    for j in k.split(';'):
        line += j+';'
        if line not in aggregate_taxa:
            aggregate_taxa[line] = [len_counts,buscos]
        else:
            print(aggregate_taxa[line][0])
            print(counts)
            aggregate_taxa[line][0] += len_counts
            aggregate_taxa[line][1].update(buscos)
            print(aggregate_taxa[line][0])

print('aggregated results. writing out to taxonomic report')

with open('Taxonomic_report.txt','w') as out:
	for k,v in sorted(aggregate_taxa.items()):
		counts,buscos = v[0],v[1]
		out.write(k+'\t'+str(counts)+'\t'+str(len(buscos))+'\n')





